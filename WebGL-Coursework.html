<!DOCTYPE html>
<html lang="en">

<head>
	<title>CM20219 – Coursework 2 – WebGL</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}
	</style>
</head>

<body>
	<script src="three-r134.js"></script>
	<script src="dat.gui.min.js"></script>
	<script>
		"use strict"; // https://stackoverflow.com/q/1335851/72470

		// Global variables that are available in all functions.
		// Note: You can add your own here, e.g. to store the rendering mode.
		var camera, scene, renderer, mesh;

		// Initialise the scene, and draw it for the first time.
		var cubeOptions = {
			wireframe: false,
			drawCube: true,
			rotation_x: 0,
			rotation_y: 0,
			rotation_z: 0,
			resetAge: false,
			reset: function() {
				cube.rotation.x = 0;
				cube.rotation.y = 0;
				cube.rotation.z = 0;
				cubeOptions.rotation_x = 0;
				cubeOptions.rotation_y = 0;
				cubeOptions.rotation_z = 0;

			}
		};

		init();

		// // TASK: Draw a cube (requirement 1)-----------------
		//Define Box
		const geometry = new THREE.BoxGeometry(2,2,2);
		//Define material
		const material = new THREE.MeshPhongMaterial({ color: 0x00ffff, wireframe: false });
		//Build cube using box geometry & material
		//Mesh => Takes Geometry and applies Material
		var cube = new THREE.Mesh( geometry, material );
		cube.position.set(0,0,0)

		//Add cube to scene
		scene.add( cube );//Default pos = (0,0,0)

		animate();


		var gui = new dat.GUI();

		var cubeGroup = gui.addFolder('Cube');
		var drawCube = cubeGroup.add(cubeOptions, 'drawCube').name('Draw Cube')
		.onChange((value) => {
			if (value == true) scene.add(cube);
			else scene.remove(cube);
		});

		var control = gui.addFolder('Control');
		control.add(cubeOptions, 'rotation_x', 0,10,0.1).name('Rotation - X');
		control.add(cubeOptions, 'rotation_y', 0,10,0.1).name('Rotation - Y');
		control.add(cubeOptions, 'rotation_z', 0,10,0.1).name('Rotation - Z');
		gui.add(cubeOptions, 'reset').onChange((value) =>{
			resetSliders();
		});

		/* Here is the update */
		var resetSliders = function (name) {
    for (var i = 0; i < control.__controllers.length; i++) {
            control.__controllers[i].setValue(0);
    	}
		};



		// Listen for keyboard events, to react to them.
		// Note: there are also other event listeners, e.g. for mouse events.
		document.addEventListener('keydown', handleKeyDown);

		function cubeControl() {
			if (cubeOptions) {
				cube.rotation.x += cubeOptions.rotation_x * 0.01;
				cube.rotation.y += cubeOptions.rotation_y * 0.01;
				cube.rotation.z += cubeOptions.rotation_z * 0.01;

			}
		}

		// Scene initialisation. This function is only run once, at the very beginning.
		function init() {
			scene = new THREE.Scene();

			// Set up the camera, move it to (3, 4, 5) and look at the origin (0, 0, 0).
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(3, 4, 5);
			camera.lookAt(new THREE.Vector3(0, 0, 0));

			// Draw a helper grid in the x-z plane (note: y is up).
			scene.add(new THREE.GridHelper(10, 20, 0xffffff));

			// TASK: Draw a cube (requirement 1).
			// TASK: Visualise the axes of the global coordinate system (requirment 2).

			// TASK: Visualise the axes of the global coordinate system (requirment 2).
			const lineMatX = new THREE.LineBasicMaterial( {color: 0xff0000});//Red
			const lineMatY = new THREE.LineBasicMaterial( {color: 0x0ff00});//Green
			const lineMatZ = new THREE.LineBasicMaterial( {color: 0x000ff});//Blue

			//Array to store points
			const linePointsX = [];
			linePointsX.push(new THREE.Vector3(0,0,0));//Define start point
			linePointsX.push(new THREE.Vector3(10,0,0));//Define end point

			const linePointsY = [];
			linePointsY.push(new THREE.Vector3(0,0,0));
			linePointsY.push(new THREE.Vector3(0,10,0));

			const linePointsZ = [];
			linePointsZ.push(new THREE.Vector3(0,0,0));
			linePointsZ.push(new THREE.Vector3(0,0,10));

			//Create geometry objects from line point arrays
			const lineGeometryX = new THREE.BufferGeometry().setFromPoints(linePointsX);
			const lineGeometryY = new THREE.BufferGeometry().setFromPoints(linePointsY);
			const lineGeometryZ = new THREE.BufferGeometry().setFromPoints(linePointsZ);

			//Define Line objects from respective geometries & material
			const lineX = new THREE.Line(lineGeometryX, lineMatX);
			const lineY = new THREE.Line(lineGeometryY, lineMatY);
			const lineZ = new THREE.Line(lineGeometryZ, lineMatZ);

			//Add objects into scene
			scene.add(lineY, lineX, lineZ);


			// Basic ambient lighting.
			scene.add(new THREE.AmbientLight(0xffffff));
			// TASK: add more complex lighting for 'face' rendering mode (requirement 4).
			const color = 0xFFFFFF;
			const intensity = 0.4;
			const light = new THREE.DirectionalLight(color, intensity);
			light.position.set(-1, 2, 4);
			scene.add(light);


			// Set up the Web GL renderer.
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio); // HiDPI/retina rendering
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			// Handle resizing of the browser window.
			window.addEventListener('resize', handleResize, false);
		}

		// Handle resizing of the browser window.
		function handleResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		// Animation loop function. This function is called whenever an update is required.
		function animate() {
			requestAnimationFrame(animate);
			cubeControl();

			// TASK: This is a good place for code that rotates your cube (requirement 3).

			// Render the current scene to the screen.
			renderer.render(scene, camera);
		}

		// Handle keyboard presses.
		function handleKeyDown(event) {
			switch (event.key) {
				// Render modes.
				case 'f': // f = face
					scene.remove(cube);
					cube = new THREE.Mesh(geometry, material );
					scene.add(cube);
					break;

				case 'e': // e = edge
					scene.remove(cube);
					const materialWire = new THREE.MeshPhongMaterial({ color: 0x00ffff, wireframe: true });
					cube = new THREE.Mesh( geometry, materialWire );
					scene.add(cube);
					break;

				case 'v': // v = vertex
					scene.remove(cube);
					const materialVertex = new THREE.PointsMaterial({color: 0xFF0000});
					cube = new THREE.Points(geometry, materialVertex);
					scene.add(cube);
					break;

				// TASK: add code for starting/stopping rotations (requirement 3).
			}
		}
	</script>
</body>

</html>
