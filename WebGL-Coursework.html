<!DOCTYPE html>
<html lang="en">

<head>
	<title>CM20219 – Coursework 2 – WebGL</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}
	</style>
</head>

<body>
	<script src="three-r134.js"></script>
	<script src="dat.gui.min.js"></script>
	<script src="OBJLoader.js"></script>
	<script type="module">

		"use strict"; // https://stackoverflow.com/q/1335851/72470
		//Setup Cannon Physics World
		import * as CANNON from 'https://cdn.skypack.dev/cannon-es/dist/cannon-es.js'
		const world = new CANNON.World({gravity: new CANNON.Vec3(0, -9.82, 0)}); //Gravity: 9.82m/s

		//Global variables
		var camera, scene, renderer, mesh, bunny, vBunny, boxBody, plane, cubeMesh, grid ;

		//Create set of paramters for Cube
		var cubeOptions = {
			wireframe: false,
			enable: true,
			diceMode: false,
			spin: false,
			rotation_x: 0,
			rotation_y: 0,
			rotation_z: 0,
			//Reset function: invoked by GUI button to reset cube params
			reset: function() {
				cube.rotation.x = 0;
				cube.rotation.y = 0;
				cube.rotation.z = 0;
				cubeOptions.rotation_x = 0;
				cubeOptions.rotation_y = 0;
				cubeOptions.rotation_z = 0;
			}
		};

		//Create set of parameters for Bunny OBJ object
		var bunnyOptions = {
      enable: false,
			vertex: false,
			rotation_x: 0,
			rotation_y: 0,
			rotation_z: 0,
			//Reset function: invoked by GUI button to reset cube params
			reset: function() {
				bunny.rotation.x = 0;
				bunny.rotation.y = 0;
				bunny.rotation.z = 0;
				bunnyOptions.rotation_x = 0;
				bunnyOptions.rotation_y = 0;
				bunnyOptions.rotation_z = 0;
			}
}
		//Create set of parameters for camera in scnee
		var cameraOptions = {
			orbit: false,
			moveUp: false,
			moveDown: false,
			moveLeft: false,
			moveRight: false,
			moveIn: false,
			moveOut: false,
		};

		//Setup three.js environment
		init();
		init_world();
		create_gui();

		//Define physics world
		function init_world() {
			//Create & Add body to hold physics dice
			const boxShape = new CANNON.Box(new CANNON.Vec3(1, 1, 1));
			boxBody = new CANNON.Body({ mass: 1, shape: boxShape })
			world.addBody(boxBody)

			//Create ground plane for collisions
			const groundBody = new CANNON.Body({
				type: CANNON.Body.STATIC,
				shape: new CANNON.Plane(),
			})
			//Set quaternion to determine rotation (up for ground plane)
			groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
			world.addBody(groundBody)

			const geometry = new THREE.PlaneGeometry( 30, 30 );
			const material = new THREE.MeshBasicMaterial( {color: 0x808080, side: THREE.DoubleSide} );//nardo grey
			plane = new THREE.Mesh(geometry, material);
			plane.rotation.x = Math.PI / 2;
	}

		//Load texture for dice
		const textureLoader = new THREE.TextureLoader();
		const loader = new THREE.TextureLoader();
    const cubeMaterials = [
        new THREE.MeshBasicMaterial({ map: loader.load('Textures/dice-one.png') }), //right side
        new THREE.MeshBasicMaterial({ map: loader.load('Textures/dice-two.png')}), //left side
        new THREE.MeshBasicMaterial({ map: loader.load('Textures/dice-three.png')}), //top side
        new THREE.MeshBasicMaterial({ map: loader.load('Textures/dice-four.png')}), //bottom side
        new THREE.MeshBasicMaterial({ map: loader.load('Textures/dice-five.png')}), //front side
        new THREE.MeshBasicMaterial({ map: loader.load('Textures/dice-six.png')}), //back side
    ];

		//Load bunny object using OBJLoader.js
		var objloader = new THREE.OBJLoader( );
    objloader.load( 'bunny-5000.obj',
			function ( object ) {
				bunny = object;
				//Manually set scale and position of bunny
				//XXX: Optimize with bounding box scaling factors
				bunny.scale.x = 0.4;
				bunny.scale.y = 0.4;
				bunny.scale.z = 0.4;
				bunny.position.set(-0.4,0,-0.1);
			});


		//TASK: Draw a cube (requirement 1)-----------------
		//Define cube from box geometry & phong material
		const geometry = new THREE.BoxGeometry(2,2,2);
		const material = new THREE.MeshPhongMaterial({ color: 0x00ffff, wireframe: false });
		var cube = new THREE.Mesh( geometry, cubeMaterials);

		//Add cube to scene
		scene.add( cube );//Default pos = (0,0,0)
		//END TASK 1-------------------------------------------

		//Define variables for animate function
		//TODO: Find a place for this
		var velocity = new THREE.Vector3();
		var tPrev = performance.now(); //Get current timestamp
		const timeStep = 1 / 60; // seconds
		var lastCallTime;

		animate();


		function create_gui() {

		//Define GUI from dat-gui (dat.gui.min.js)
		var gui = new dat.GUI(); //Instantiate GUI

		//Create folder to hold basic objects: Cube, Bunny
		var drawGroup = gui.addFolder('Objects');
		//Button: toggles state of 'cubeOptions.enable'
		var addCube = drawGroup.add(cubeOptions, 'enable').name('Enable Cube')
			.onChange((value) => {
				if (value == true) scene.add(cube); //Add cube to scene
				else scene.remove(cube); //Remove cube from scene
		});
		//Button: toggles state of 'bunnyOptions.enable'
		var addBunny = drawGroup.add( bunnyOptions, 'enable' ).name( 'Enable Bunny' )
    	.onChange( function(value) {
      	if ( alue == true) scene.add(bunny); //Add bunny to scene
      	else scene.remove(bunny); //Remove bunny from scene
    });

		//Create folder to hold parameters of cube rotation
		var control = gui.addFolder('Cube Control');
		control.add(cubeOptions, 'rotation_x', 0,10,0.1).name('Rotation - X');
		control.add(cubeOptions, 'rotation_y', 0,10,0.1).name('Rotation - Y');
		control.add(cubeOptions, 'rotation_z', 0,10,0.1).name('Rotation - Z');

		//Create folder to hold parameters of bunny rotation
		var bunnyFolder = gui.addFolder('Bunny Control');
		bunnyFolder.add(bunnyOptions, 'rotation_x', 0,10,0.1).name('Rotation - X');
		bunnyFolder.add(bunnyOptions, 'rotation_y', 0,10,0.1).name('Rotation - Y');
		bunnyFolder.add(bunnyOptions, 'rotation_z', 0,10,0.1).name('Rotation - Z');

		//Create folder to hold parameters for camera
		var cam = gui.addFolder('Camera');
		//Button: toggles state of camera for Orbit mode
		cam.add(cameraOptions, 'orbit').onChange((value) =>{
			if (value == 1) cameraOptions.orbit = true; //Enable orbit mode
			else cameraOptions.orbit = false; //Disable orbit mode
		});

		//Buttons:
		gui.add(cubeOptions, 'reset').name('Reset Cube').onChange((value) =>{
			resetCubeSliders(); //When pressed, resets sliders for cube rotation
		});
		gui.add(bunnyOptions, 'reset').name('Reset Bunny').onChange((value) =>{
			resetBunnySliders();//When pressed, resets sliders for bunny rotation
		});

		//Create folder to hold options for 'Dice Mode'
		var diceFolder = gui.addFolder('Dice Control');
		diceFolder.add(cubeOptions, 'diceMode').name('Dice Mode').onChange((value) =>{
			if (value == 1){
				//Enable dice mode in cube parameters
				cubeOptions.diceMode = true;
				//Remove helper grid & add dice plane
				scene.remove(grid);
				scene.add(plane);
			}
			else {
				cubeOptions.diceMode = false;
				//Remove dice plane & add helper grid
				scene.remove(plane);
				scene.add(grid);
			}
		});
		//Button: Executes dice roll when pressed
		var roll = { add:function(){
			throwDice();
		}};
		//Add button to roll dice
		diceFolder.add(roll,'add').name('Roll Dice');
	}

	//Reset rotation sliders for cube (x, y, z)
	var resetCubeSliders = function (name) {
	//__controllers -> Array of variable objects in folder (e.g. slider values)
	//Iterate through each slider
	for (var i = 0; i < control.__controllers.length; i++) {
					control.__controllers[i].setValue(0); //Set each slider to 0
		}
	};

	//Reset rotation sliders for bunny (x, y, z)
	var resetBunnySliders = function (name) {
	//__controllers -> Array of variable objects in folder (e.g. slider values)
	//Iterate through each slider
	for (var i = 0; i < bunnyFolder.__controllers.length; i++) {
					bunnyFolder.__controllers[i].setValue(0);//Set each slider to 0
		}
	};

	//Function to manage rolling dice
	function throwDice() {
			boxBody.position.set(0,5,0);//Set starting position of dice
			//Add pre-spin to dice
			cubeOptions.spin = true;
			//Calculate random x,y,z spin variables
			var ranX = Math.floor(Math.random() * 10) + 1;
			var ranY = Math.floor(Math.random() * 10) + 1;
			var ranZ = Math.floor(Math.random() * 10) + 1;

			//Give angular velocity to dice before dropped
			boxBody.angularVelocity.set(ranX,ranY,ranZ);
			//Remove velocity after 2 seconds
			//XXX: EITHER: REMOVE VELOCITY AFTER HIT GROUND OR ENABLE PHYSICS AFTER TIME PERIOD
			setTimeout(() => {  boxBody.angularVelocity.set(0,0,0); }, 2000);
		}


		// Listen for keyboard events, to react to them.
		// Note: there are also other event listeners, e.g. for mouse events.
		document.addEventListener('keydown', handleKeyDown); //Executes on key press (down)
		document.addEventListener('keyup', handleKeyUp)//Executes on key release (up)

		function cubeControl() {
			if (cubeOptions) {
				//Accumulate rotation vector for each axis
				cube.rotation.x += cubeOptions.rotation_x * 0.01;
				cube.rotation.y += cubeOptions.rotation_y * 0.01;
				cube.rotation.z += cubeOptions.rotation_z * 0.01;
			}
		}
		function bunnyControl() {
			if (bunnyOptions.enable) {
				//Accumulate rotation vector for each axis
				bunny.rotation.x += bunnyOptions.rotation_x * 0.01;
				bunny.rotation.y += bunnyOptions.rotation_y * 0.01;
				bunny.rotation.z += bunnyOptions.rotation_z * 0.01;
			}
		}

		//Function to end each dice roll
		function stopRoll() {
			var localUp = new CANNON.Vec3();
			//Create quaternion object for dice
			var inverseBodyOrientation = new CANNON.Quaternion();
			//Calculate limit (45 degrees) in radians for dice resting angle
			var limit = Math.sin(Math.PI/4);

			//Set the world up vector to local (dice) space
			localUp.set(0,1,0);
			//Invert quaternion for dice
			boxBody.quaternion.inverse(inverseBodyOrientation);
			//vmult = multiply local upn vector by quaternion
			inverseBodyOrientation.vmult(localUp, localUp);
			var result;

			//Determine vector has the greatest 'up' component
			if(localUp.x > limit){
					alert("You rolled: 1");
			} else if(localUp.x < -limit){
					alert("You rolled: 2");
			} else if(localUp.y > limit){
				alert("You rolled: 3");
			} else if(localUp.y < -limit){
				alert("You rolled: 4");
			} else if(localUp.z > limit){
				alert("You rolled: 5")
			} else if(localUp.z < -limit){
				alert("You rolled: 6");
			} else {
				console.log("not flat")
				//No greatest up component i.e. dice not flat
			}
		}

		// Scene initialisation. This function is only run once, at the very beginning.
		function init() {
			scene = new THREE.Scene();

			// Set up the camera, move it to (3, 4, 5) and look at the origin (0, 0, 0).
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(3, 4, 5);
			camera.lookAt(new THREE.Vector3(0, 0, 0));

			// Draw a helper grid in the x-z plane (note: y is up).
			grid = new THREE.GridHelper(10, 20, 0xffffff)
			scene.add(grid);

			// TASK: Visualise the axes of the global coordinate system (requirment 2).------

			//Create material for each axis line (changing color for each)
			const lineMatX = new THREE.LineBasicMaterial( {color: 0xff0000});//Red
			const lineMatY = new THREE.LineBasicMaterial( {color: 0x0ff00});//Green
			const lineMatZ = new THREE.LineBasicMaterial( {color: 0x000ff});//Blue

			//Array to store points
			const linePointsX = [];
			linePointsX.push(new THREE.Vector3(0,0,0));//Define start point
			linePointsX.push(new THREE.Vector3(10,0,0));//Define end point

			const linePointsY = [];
			linePointsY.push(new THREE.Vector3(0,0,0));
			linePointsY.push(new THREE.Vector3(0,10,0));

			const linePointsZ = [];
			linePointsZ.push(new THREE.Vector3(0,0,0));
			linePointsZ.push(new THREE.Vector3(0,0,10));

			//Create geometry objects from line point arrays
			const lineGeometryX = new THREE.BufferGeometry().setFromPoints(linePointsX);
			const lineGeometryY = new THREE.BufferGeometry().setFromPoints(linePointsY);
			const lineGeometryZ = new THREE.BufferGeometry().setFromPoints(linePointsZ);

			//Define Line objects from respective geometries & material
			const lineX = new THREE.Line(lineGeometryX, lineMatX);
			const lineY = new THREE.Line(lineGeometryY, lineMatY);
			const lineZ = new THREE.Line(lineGeometryZ, lineMatZ);

			//Add objects into scene
			scene.add(lineY, lineX, lineZ);

			//END TASK 2-------------------------------


			// TASK: add more complex lighting for 'face' rendering mode (requirement 4).
			const color = 0xFFFFFF; //Light color
			const intensity = 2; //Light intensity
			//Define light
			const light = new THREE.DirectionalLight(color, intensity);
			light.position.set(-1, 2, 4); //Set light position
			scene.add(light);//Add light to scene


			// Set up the Web GL renderer.
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio); // HiDPI/retina rendering
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			// Handle resizing of the browser window.
			window.addEventListener('resize', handleResize, false);
		}

		// Handle resizing of the browser window.
		function handleResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function setBunnyRender(mode,b) {
	 			if (mode == "edge") {
						if (bunnyOptions.vertex) {
							console.log('jefe');
							scene.remove(vBunny);
							scene.add(bunny);
							bunnyOptions.vertex = false;
						}
						bunny.children[0].material.wireframe = true;
					}
				if (mode == "vertex") {
					scene.remove(bunny)
					bunnyOptions.vertex = true;

					scene.add(vBunny)


					}
				if (mode == "face") {
					if (bunnyOptions.vertex) {
						scene.remove(vBunny)
						scene.add(bunny)
						bunnyOptions.vertex = false;
					}
					bunny.children[0].material.wireframe = false;
				}
		}

		function setCubeRender(mode) {
			if (cubeOptions.enable) {
				if (mode == "edge") {
					scene.remove(cube);
					const materialWire = new THREE.MeshPhongMaterial({ color: 0x00ffff, wireframe: true });
					cube = new THREE.Mesh( geometry, materialWire );
					scene.add(cube);
					}
				if (mode == "vertex") {
					scene.remove(cube);
					const materialVertex = new THREE.PointsMaterial({color: 0xFF0000});
					materialVertex.size = 0.25;
					cube = new THREE.Points(geometry, materialVertex);
					scene.add(cube);
					}
				if (mode == "face") {
					scene.remove(cube);
					cube = new THREE.Mesh(geometry, material );
					scene.add(cube);
				}
			}
		}

		// Animation loop function. This function is called whenever an update is required.


		function animate() {
			requestAnimationFrame(animate);
			if (!lastCallTime) {
		    world.step(timeStep)
		  } else {
		   	const dt = time - lastCallTime
		    world.step(timeStep, dt)
		  }
		  lastCallTime = time
			cubeControl();
			bunnyControl();


			if (cubeOptions.spin) {

					if (boxBody.angularVelocity.x < 0.001 && boxBody.angularVelocity.y < 0.001 && boxBody.angularVelocity.z < 0.001) {
						console.log('stopped rolling');
						stopRoll();
						cubeOptions.spin = false;

					}

			}


			var time = performance.now();
      var delta = ( time - tPrev ) / 1000;

			velocity.x -= velocity.x * 1.2 * delta;
			velocity.y -= velocity.y * 1.2 * delta;
			velocity.z -= velocity.z * 1.2 * delta;

			if (cubeOptions.diceMode) {

			cube.position.copy(boxBody.position)
  		cube.quaternion.copy(boxBody.quaternion)

		}



      //if the user pressed 'up' or 'w', set velocity.z to a value > 0.
      if ( cameraOptions.moveUp ) velocity.y += 3.0 * delta;
      	camera.translateY( velocity.y * delta );

			if ( cameraOptions.moveDown ) velocity.y -= 3.0 * delta;
      	camera.translateY( velocity.y * delta );

			if ( cameraOptions.moveLeft ) velocity.x -= 3.0 * delta;
      	camera.translateX( velocity.x * delta );

			if ( cameraOptions.moveRight ) velocity.x += 3.0 * delta;
      	camera.translateX( velocity.x * delta );

			if ( cameraOptions.moveIn ) velocity.z -= 3.0 * delta;
      	camera.translateZ( velocity.z * delta );

			if ( cameraOptions.moveOut ) velocity.z += 3.0 * delta;
      	camera.translateZ( velocity.z * delta );
    tPrev = time;

			// TASK: This is a good place for code that rotates your cube (requirement 3).
			if (cameraOptions.orbit) {
				if (!cameraOptions.moveLeft || !cameraOptions.moveRight) {
					if (camera.position.z >= 0) {
						camera.up = new THREE.Vector3(0,1,0);
					} else {
						camera.up = new THREE.Vector3(0,-1,0);
					}
				}
				camera.lookAt(0,0,0);

			}
			// Render the current scene to the screen.
			renderer.render(scene, camera);
		}



		// Handle keyboard presses.
		function handleKeyDown(event) {
			switch (event.key) {
				// Render modes.
				case 'f': // f = face
					setCubeRender("face");
					setBunnyRender("face");
					break;

				case 'e': // e = edge
					setCubeRender("edge");
					setBunnyRender("edge");
					break;

				case 'v': // v = vertex
					setCubeRender("vertex");
					var bmat = new THREE.PointsMaterial({color: 0xFF0000});
					var bgeo = bunny.children[0].geometry;

					bmat.size = 0.025;
					vBunny = new THREE.Points( bgeo, bmat );
					vBunny.scale.x = 0.4;
					vBunny.scale.y = 0.4;
					vBunny.scale.z = 0.4;
					vBunny.position.set(-0.4,0,-0.1);
					setBunnyRender("vertex");
					break;



				case 'ArrowLeft':
					cameraOptions.moveLeft = true;
					break;

				case 'ArrowRight':
					cameraOptions.moveRight = true;
					break;

				case 'ArrowUp':
					cameraOptions.moveUp = true;
					break;

				case 'ArrowDown':
					cameraOptions.moveDown = true;
					break;

				case 'w':
					cameraOptions.moveIn = true;
					break;

				case 's':
					cameraOptions.moveOut = true;
					break;
			}
		}

		// Handle keyboard presses.
		function handleKeyUp(event) {
			switch (event.key) {

				case 'ArrowLeft':
					cameraOptions.moveLeft = false;
					break;

				case 'ArrowRight':
					cameraOptions.moveRight = false;
					break;

				case 'ArrowUp':
					cameraOptions.moveUp = false;
					break;

				case 'ArrowDown':
					cameraOptions.moveDown = false;
					break;

				case 'w':
					cameraOptions.moveIn = false;
					break;

				case 's':
					cameraOptions.moveOut = false;
					break;
			}
		}

	</script>
</body>

</html>
