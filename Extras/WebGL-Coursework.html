<html>
	<head>
		<title>JL26889 Visual Computing Coursework</title>
        <meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body
            {
                margin: 0;
                overflow: hidden;
            }
			canvas
            {
                width: 100%;
                height: 100%;
            }
		</style>
	</head>
	<body>
        <script src="three/three.js"></script>
        <script src="three/OBJLoader.js"></script>
        <script src="three/dat.gui.min.js"></script>
        <!-- Custom Vertex Shader Code !-->
        <script id="vertexShader" type="x-shader/x-vertex">
            uniform vec3 viewVector;
            uniform float c;
            uniform float p;
            varying float intensity;
            void main()
            {
                vec3 vNormal = normalize( normalMatrix * normal );
                vec3 vNormel = normalize( normalMatrix * viewVector );
                intensity = pow( c - dot(vNormal, vNormel), p );
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
        </script>
        <!-- Custom Fragment Shader Code -->
        <script id="fragmentShader" type="x-shader/x-vertex">
            uniform vec3 glowColor;
            varying float intensity;
            void main()
            {
                vec3 glow = glowColor * intensity;
                gl_FragColor = vec4( glow, 1.0 );
            }
        </script>
        
		<script>
            "use strict";
            var scale = { x: 0, y: 0, z: 0, actual: 0 }, translate = { x: 0, y: 0, z: 0 };
            var firstIteration = true;
            var camera, scene, renderer;                                                // Camera/Scene/Renderer are used across the program in order to generate the scene.
            var cube, cubeMaterials, spinPos = 0, bouncePos = 0;                        // Variables for controlling Cube
            var bunny, bunnyTexture;
            var grid, axes;
            var dirLight, dirLightSrc, dirLightGlow, hemiLight, moon;                     // Variables for controlling the light source(s)
            var xAxis = new THREE.Vector3(1,0,0), yAxis = new THREE.Vector3(0,1,0); // Translation matrices for translation horizontally and vertically
            var mouseDown = false, mouseX = 0, mouseY = 0;                          // Variables for mouse controls
            var oldVector = new THREE.Vector3(), lookVec = new THREE.Vector3( 0, 0, 0 );

            /************************* GUI/Control Parameters **************************/

            var colOptions = {
                black:      0x000000,
                white:      0xFFFFFF,
                red:        0xFF0000,
                lime:       0x00FF00,
                blue:       0x0000FF,
                yellow:     0xFFFF00,
                cyan:       0x00FFFF,
                magenta:    0xFF00FF,
                silver:     0xC0C0C0,
                maroon:     0x800000,
                olive:      0x808000,
                green:      0x008000,
                purple:     0x800080,
                teal:       0x008080,
                navy:       0x000080,
            }
            
            var cubeParams = {
                rotate: false,
                drawCube: true,
                cubeDistanceSet: 0,
                cubeBounce: false,
                xRotateSet: 2.5,
                yRotateSet: 2.5,
                zRotateSet: 2.5,
                spin: false,
                resetCube: function () {
                    cube.position.set( 0, 0, 0 );
                    cube.rotation.y = 0;
                    cube.rotation.z = 0;
                    cube.rotation.x = 0;
                    cubeParams.rotCurrent.x = 0;
                    cubeParams.rotCurrent.y = 0;
                    cubeParams.rotCurrent.z = 0;
                    cubeParams.radialDistCurrent = 0;
                },
                rotCurrent: { x: 0, y: 0, z: 0 },
                radialDistCurrent: 0,
            }
        
            var bunnyParams = {
                draw: true,
                rotate: false,
                jump: false,
                xRotateSet: 0,
                yRotateSet: 0,
                zRotateSet: 0,
                rotCurrent: { x: 0, y: 0, z: 0 },
            }
        
            var cameraControls = {
                rotation: { X: 0, Y: 0.25 },
                distance: 70,
                lookAt: new THREE.Vector3( 0, 0, 0 ),
            }
        
            var lightParams = {
                dirLightIntensity: 1,
                dirLight: true,
                dirLightHeight: 10,
                dirLightColor: colOptions.white,
                ambientLightIntensity: 1,
                ambientLight: true,
            }
        
            // Sets parameters for the GUI in top right hand corner
            var params = {
                grid: false,
                axes: false,
            };

            /************************* SETUP OF GUI **************************/

            /* The following section sets up the GUI, including all buttons and listen() functions,
             allowing the GUI to make changes to the scene whenever a button is pressed or a slider
             is moved. */
            var gui = new dat.GUI();
            
            /* This is the folder for cube controls. */
            var cubeFolder = gui.addFolder( 'Cube' );
            var drawCube = cubeFolder.add( cubeParams, 'drawCube' ).name( 'Draw Cube' ).listen();
            drawCube.onChange(function(value) {
                              if ( value == true ) scene.add( cube );
                              else scene.remove( cube );
                              });
            var cubeRotate = cubeFolder.add( cubeParams, 'rotate').listen();
            cubeRotate.onChange( function(value) {
                                if ( value == false ) {
                                cubeParams.rotCurrent.x = 0;
                                cubeParams.rotCurrent.y = 0;
                                cubeParams.rotCurrent.z = 0;
                                }
                                });
            cubeFolder.add( cubeParams, 'spin' );
            cubeFolder.add( cubeParams, 'cubeBounce' );
            cubeFolder.add( cubeParams, 'cubeDistanceSet', 0, 7, 0.1 ).name( 'Radial Distance' );
            cubeFolder.add( cubeParams, 'xRotateSet', 0, 10, 0.1 ).name( 'X Rotation' );
            cubeFolder.add( cubeParams, 'yRotateSet', 0, 10, 0.1 ).name( 'Y Rotation' );
            cubeFolder.add( cubeParams, 'zRotateSet', 0, 10, 0.1 ).name( 'Z Rotation' );
            cubeFolder.add( cubeParams, 'resetCube' );
            
            var bunnyFolder = gui.addFolder( 'bunny Controls' );
            var drawBunny = bunnyFolder.add( bunnyParams, 'draw' ).name( 'Draw Bunny' ).listen();
            drawBunny.onChange( function(value) {
                               if ( value == true ) scene.add( bunny );
                               else scene.remove( bunny );
                               });
           bunnyFolder.add( bunnyParams, 'jump' ).name( 'hoppity hop' );
           bunnyFolder.add( bunnyParams, 'rotate' );
           bunnyFolder.add( bunnyParams, 'xRotateSet', 0, 10, 0.1 ).name( 'X Rotation' );
           bunnyFolder.add( bunnyParams, 'yRotateSet', 0, 10, 0.1 ).name( 'Y Rotation' );
           bunnyFolder.add( bunnyParams, 'zRotateSet', 0, 10, 0.1 ).name( 'Z Rotation' );
           
            // Add folder to control the light source
            var lightFolder = gui.addFolder( 'Light Controls' );
            // Decides if the directional light is rendered or not. Also turns on/off the moon and the accompanying glow for the moon
            var dirLightRender = lightFolder.add( lightParams, 'dirLight' ).name('Directional Light').listen();
            dirLightRender.onChange( function(value) {
                                    if ( value == true ) {
                                        scene.add( dirLight, dirLightGlow );
                                        dirLightGlow.position.y = dirLightSrc.position.y = dirLightSrc.position.y = lightParams.dirLightHeight;
                                    }
                                    else
                                    scene.remove( dirLight, dirLightGlow );
                                    });
            /* Adjusts the intensity of the light. For reference, "c" value in the glow is set at
             1.0, and the "p" value ranges from 0 to 6, with 6 giving the weakest glow and 0 giving
             the strongest. This changes bothe the intensity of the actual directional light as
             well as the intensity of the source glow. */
            var dirLightIntensity = lightFolder.add( lightParams, 'dirLightIntensity', 0, 2 ).name('dir Intensity').listen();
            dirLightIntensity.onChange(function(value) { dirLight.intensity = value;  dirLightGlow.material.uniforms[ "p" ].value = 6 - (value * 3) });
            /* Simply adjusts the height of the directional light. Also set in turning on/off the
             light so that the light is always rendered at the correct altitude. */
            var dirLightHeight = lightFolder.add( lightParams, 'dirLightHeight', 0, 50 ).name('Light Height').listen();
            dirLightHeight.onChange(function(value) { dirLightGlow.position.y = dirLightSrc.position.y = dirLight.position.y = value; } );
            /* Changes the colour of the directional light source. This also adjust the colour of
             the glow (hence the grandfathered name "glowColor"). */
            var glowColor = lightFolder.add( lightParams, 'dirLightColor', { 'white': colOptions.white, 'red': colOptions.red, 'yellow': colOptions.yellow, 'green': colOptions.green, 'blue': colOptions.blue } ).name('Directional Light Color').listen();
            glowColor.onChange( function(value) { dirLightGlow.material.uniforms.glowColor.value.setHex( value ); dirLight.color.setHex( value ); });
            /* Turns on and off the ambient hemisphere light - also sets the position of the light
             every time so that is always in the right place */
            var hemiLightRender = lightFolder.add( lightParams, 'ambientLight' ).name('Ambient Light').listen();
            hemiLightRender.onChange( function(value) {
                                     if ( value == true ) { scene.add( hemiLight ); hemiLight.position.set( 0, 50, 0 ); }
                                     else scene.remove( hemiLight ); });
            /* Adjusts intensity of the ambient hemisphere light. Does what it says on the box, and
             not much more. */
            var hemiLightIntensity = lightFolder.add( lightParams, 'ambientLightIntensity', 0, 2 ).name('amb Intensity').listen();
            hemiLightIntensity.onChange(function(value) { hemiLight.intensity = value; } );
            
            // Adds checkbox to add or remove the 10x10 grid plane
            var gridAddRemove = gui.add( params, 'grid' ).name( 'Draw Grid' ).listen();
            gridAddRemove.onChange(function(value) { grid.visible = value; } );
            // Checkbox to add or remove the XYZ axes
            var axesAddRemove = gui.add( params, 'axes' ).name( 'Draw Axes' ).listen();
            axesAddRemove.onChange(function(value) { axes.visible = value; } );
            
            gui.open();

            /************************* CONTROL OF CAMERA **************************/

            /* CAMERA CONTROLS: This section contains functions needed
             to operate the orbit of the camera around the scene, as well
             as the vertical and horizontal pan controlled by the keyboard
             arrow keys. */


            /* function: calcCamDiff - finds the difference between the current camera
             position and a stored position. Then saves this value to a new lookAt 
             vector, also acting as an offset for camera translation. */
            function calcCamDiff() {
                var newVector = camera.getWorldDirection().add(camera.position);
                lookVec.x -= oldVector.x - newVector.x;
                lookVec.y -= oldVector.y - newVector.y;
                lookVec.z -= oldVector.z - newVector.z;
            }

            /* function: moveCamera - takes how much the mouse is moving
             as X and Y coordinates, and then shifts the camera by the
             required amount in the correct direction. Also resets the camera
             to be looking at the origin after each shift so that the scene
             does not repeatedly break. */
            function moveCamera( deltaX, deltaY ) {
                /* cameraControls.rotation is a vector with 2 values, storing
                 the X and Y values of how much the camera needs to be shifted
                 by. These values are divided by an appropriate amount so that
                 the camera does not spin wildly out of control. (i.e. slows
                 down the rotation of the camera. */
                cameraControls.rotation.X += deltaX / 1000;
                cameraControls.rotation.Y += deltaY / 300;
                /* Rail, or limit the values of the Y rotation to +0.499 and
                 -0.499. These values are chosen as they correspond with the maximum
                 values of sin(Y), which are 1 and -1 (directly above and directly
                 below the scene.) They are not +0.5 and -0.5 to prevent the camera
                 from snapping to directly overhead when rotated after being translated
                 away from the main orbit around the scene. */
                if ( cameraControls.rotation.Y <= -0.5 ) { cameraControls.rotation.Y = -0.4999; }
                else if ( cameraControls.rotation.Y >= 0.5 ) { cameraControls.rotation.Y = 0.4999; }
                /* The camera position is adjusted on each axis seperately. The X and
                 Z components, which are on the horizontal plane, are a sin and a cosine
                 function, which are combined to give a circle to orbit around the scene.
                 The cos(Y) multiplier is used to limit the radius of turn as the camera
                 goes above and below the horizon line, making the camera's orbit an
                 sphere. (Minimum values of cos(Y) at either end of the range) */
                camera.position.x = cameraControls.distance * Math.sin( cameraControls.rotation.X * Math.PI ) * Math.cos( cameraControls.rotation.Y * Math.PI );
                camera.position.x += lookVec.x;
                camera.position.z = cameraControls.distance * Math.cos( cameraControls.rotation.X * Math.PI ) * Math.cos( cameraControls.rotation.Y * Math.PI );
                camera.position.z += lookVec.z;
                camera.position.y = cameraControls.distance * Math.sin( cameraControls.rotation.Y * Math.PI );
                camera.position.y += lookVec.y;
                /* Points the camera in the direction of the origin of the scene.
                 Without this function the camera would seem to spin wildly out of
                 control. */
                camera.lookAt( lookVec );
            }
        
            /* function: onMouseMove(evt) - When this function is called, the movement
             of the mouse is translated into the difference in mouse coordinates since
             the last time this function was called. The previous value is stored in
             mouseX and mouseY, and the function moveCamera is called at the end of this
             function to translate the difference in mouse position to an actual orbit
             of the camera. */
            function onMouseMove(evt) {
                /* If the mouse has not been clicked, this function will immediately return
                 without performing any action. */
                if (!mouseDown) {
                    return;
                }
                /* This function simply cancels the default action of a click. (Prevents
                 some buggy behaviour) */
                evt.preventDefault();
                /* deltaX and deltaY are created for use only in this function, and are the
                 differences between the current mouse position and the previously recorded
                 mouse position. They are later passed to the moveCamera function. */
                var deltaX = evt.clientX - mouseX;
                var deltaY = evt.clientY - mouseY;
                /* The variables mouseX and mouseY are used to store the current values of
                 the mouse position, and will be changed again with each iteration. */
                mouseX = evt.clientX;
                mouseY = evt.clientY;
                moveCamera( deltaX, deltaY );
            }
        
            /* function: onMouseDown(evt) - is called when the mouse button is clicked.
             It changes the state of the boolean variable mouseDown, and stores the current
             mouse position when the click is first made. This storage prevents some behaviour
             where the difference in mouse positions may be taken from a previous point quite
             far away when little movement has been made. */
            function onMouseDown(evt) {
                /* This function simply cancels the default action of a click. (Prevents
                 some buggy behaviour) */
                evt.preventDefault();
                /* Changes the state of the boolean variable mouseDown, which is used to
                 determnine if the camera is actually moved or not. */
                mouseDown = true;
                /* As mentioned in the function description, stores the current values of the
                 mouse position to prevent buggy movement. */
                mouseX = evt.clientX;
                mouseY = evt.clientY;
            }
        
            /* function: onMouseUp(evt) - simply detects when the mouse button has been released,
             and changes the state of the boolean variable mouseDown, preventing the camera from
             being moved any longer.*/
            function onMouseUp(evt) {
                /* This function simply cancels the default action of a click. (Prevents
                 some buggy behaviour) */
                evt.preventDefault();
                /* Changes the state of the boolean variable mouseDown, which is used to
                 determnine if the camera is actually moved or not. */
                mouseDown = false;
            }
        
            /* function: onMouseWheel(evt) - Detects when a scroll of the mouse wheel has occured,
             and changes the "zoom" level of the scene by adjusting the multiplier used to calculate
             camera position. */
            function onMouseWheel(evt) {
                /* This function simply cancels the default action of a click. (Prevents
                 some buggy behaviour) */
                evt.preventDefault();
                /* This adds the scrolled amount to the multiplier. A scroll in the opposite direction
                 would result in evt.deltaY being a negative number, and so the multiplier would be
                 reduced instead of increased. The multiplier slows down the zoom speed so that the
                 camera doesn't move at warp speed. */
                cameraControls.distance += evt.deltaY * 0.1;
                /* Limits the camera distance between 1 and 1000. Values close to 1 land up quite
                 close to the origin of the picture and can be slow to render, while values much greater
                 than 1000 may result in the scene being too small or not rendered. */
                if ( cameraControls.distance <= 1 ) { cameraControls.distance = 1; }
                else if ( cameraControls.distance >= 1000 ) { cameraControls.distance = 1000; }
                /* Calls the function moveCamera along with no movement to adjust the camera so that
                 the new zoom level is reflected in the displayed image. */
                moveCamera( 0, 0 );
            }
        
            /* function: addMouseHandler - calls all the mouse functions, detecting if the mouse has:
             1. Moved - if button pressed, orbit camera
             2. Button Pressed
             3. Button Released
             4. Scrolled - adjust zoom level of camera. (Forward-backward translation) */
            function addMouseHandler( canvas ) {
                canvas.addEventListener( 'mousemove', onMouseMove, false);
                canvas.addEventListener( 'mousedown', onMouseDown, false);
                canvas.addEventListener( 'mouseup', onMouseUp, false);
                canvas.addEventListener( 'wheel', onMouseWheel, false );
            }

            /************************* CUSTOM ANIMATION AND MOVEMENT **************************/

            /* function: accelerate - linearly increments or decrements a value so that the animations
             on-screen do not warp from location to location when their values are adjusted. This allows
             the animation to appear smoother and more natural. */
            function accelerate(input, current, rate) {
                /* If the desired state has already been reached, there is no need to increment or decrement
                 the current state, and the function is skipped. */
                if (input != current) {
                    if (current < input) {
                        current += rate;    // "rate" allows for control over how quickly the value is incremented/decremented
                    }
                    else {
                        current -= rate;
                    }
                }
                return current
            }

            /* function: lightMovement - moves the various components of the directional lights in
             orbit around the scene, by combining the X and Z axes with the sine and cosine of the
             current date in order to create a circle. Also updates the position and height of the
             light's moon. */
            function lightMovement() {
                /* Performs the actual rotation of the light, spherical light source, and the source's
                 glow about the scene using the cosine and sine functions. An ellipse can be created by
                 making one of the multipliers greater than the other. */
                dirLightGlow.position.z = dirLightSrc.position.z = dirLight.position.z = 20 * (Math.cos(Date.now() * 0.0005));
                dirLightGlow.position.x = dirLightSrc.position.x = dirLight.position.x = 20 * (Math.sin(Date.now() * 0.0005));
                /* The moon's orbit is created by adding a smaller orbit to the original light source's
                 orbit. The moon's orbit is a small ellipse, and has some Y-directional skew as well.
                 The selected height of the directional light is added linearly to the moon's height to
                 raise or lower it with the directional light. */
                moon.position.z = 20 * (Math.cos(Date.now() * 0.0005)) + (3.5 * Math.sin(Date.now() * 0.001));
                moon.position.x = 20 * (Math.sin(Date.now() * 0.0005)) + (2.5 * Math.cos(Date.now() * 0.001));
                moon.position.y = dirLightGlow.position.y + 3 * (Math.cos(Date.now() * 0.001));
            }

            /* function: cubeMovement - deals with the orbiting, rotation and bounce of the cube. */
            function cubeMovement() {
                /* Having these lines always run allows the cube's distance from origin to be updated
                 with each frame even if the cube is not moving radially about the origin. */
                cubeParams.radialDistCurrent = accelerate ( cubeParams.cubeDistanceSet, cubeParams.radialDistCurrent, 0.01 );
                cube.position.z = cubeParams.radialDistCurrent * Math.cos(spinPos * 0.001);
                cube.position.x = cubeParams.radialDistCurrent * Math.sin(spinPos * 0.001);
                /* Starts and stops rotation of the cube depending on whether or not the "rotate"
                 checkbox is ticked. If it is, then the speed of rotation will slowly increase to the
                 selected speed, with each axis of rotation being controlled seperately. */
                if ( cubeParams.rotate == true ) {
                    cubeParams.rotCurrent.x = accelerate( cubeParams.xRotateSet, cubeParams.rotCurrent.x, 0.1 );
                    cube.rotation.x += cubeParams.rotCurrent.x * 0.01;
                    cubeParams.rotCurrent.y = accelerate( cubeParams.yRotateSet, cubeParams.rotCurrent.y, 0.1 );
                    cube.rotation.y += cubeParams.rotCurrent.y * 0.01;
                    cubeParams.rotCurrent.z = accelerate( cubeParams.zRotateSet, cubeParams.rotCurrent.z, 0.1 );
                    cube.rotation.z += cubeParams.rotCurrent.z * 0.01;
                }
                /* The bounce is offset by 0.5 to prevent clipping with the ground plane, and the cosine
                 function is taken as an absolute value so that the cube only bounces above the ground
                 plane. */
                if ( cubeParams.cubeBounce == true ) {
                    cube.position.y = 0.5 + ( 2 * Math.abs(Math.cos(bouncePos * 0.001)));
                }
                /* If the cube is spinning, this value is updated each time the function is called, moving
                 the cube radially around the origin. */
                if ( cubeParams.spin == true ) {
                    spinPos += 30;
                }
            }
        
            /* function: bunnyMovement - deals with the orbiting, rotation and bounce of the cube. */
            function bunnyMovement() {
                if ( bunnyParams.rotate == true ) {
                    bunnyParams.rotCurrent.x = accelerate( bunnyParams.xRotateSet, bunnyParams.rotCurrent.x, 0.1 );
                    bunny.rotation.x += bunnyParams.rotCurrent.x * 0.01;
                    bunnyParams.rotCurrent.y = accelerate( bunnyParams.yRotateSet, bunnyParams.rotCurrent.y, 0.1 );
                    bunny.rotation.y += bunnyParams.rotCurrent.y * 0.01;
                    bunnyParams.rotCurrent.z = accelerate( bunnyParams.zRotateSet, bunnyParams.rotCurrent.z, 0.1 );
                    bunny.rotation.z += bunnyParams.rotCurrent.z * 0.01;
                }
                if ( bunnyParams.jump == true ) {
                    bunny.position.y = Math.abs( (Math.cos(Date.now() * 0.005) + (Math.sin( Date.now() * 0.005 ))) );
                    bunny.position.z = cubeParams.radialDistCurrent * Math.cos(-0.7 + spinPos * 0.001);
                    bunny.position.x = cubeParams.radialDistCurrent * Math.sin(-0.7 + spinPos * 0.001);
                }
            }

            /************************* CUSTOM MODEL LOADERS **************************/

            function getBoundingBoxModifiers( boundingBox ) {
                /* Finds the translation necessary for the bunny's geometry, creating an offset
                 so that it will be properly centred. */
                translate.x = (boundingBox.max.x + boundingBox.min.x) / 2;
                translate.y = (boundingBox.max.y + boundingBox.min.y) / 2;
                translate.z = (boundingBox.max.z + boundingBox.min.z) / 2;
                /* Gets the correct scale of the bunny, accounting for the size of the box against
                 the size of the bunny, then picks the smallest scale needed to obtain the final
                 scale needed for the overall bunny. */
                scale.x = 2 / (Math.abs(boundingBox.max.x) + Math.abs(boundingBox.min.x));
                scale.y = 2 / (Math.abs(boundingBox.max.y) + Math.abs(boundingBox.min.y));
                scale.z = 2 / (Math.abs(boundingBox.max.z) + Math.abs(boundingBox.min.z));
                scale.actual = Math.min(scale.x, scale.y, scale.z);
            }


            /* function: loadModel - loads the actual model and applies textures and functions. This loads 
             the "face" mode for the bunny. */
            function loadModel() {
                bunny.traverse( function ( child ) {
                   if ( child instanceof THREE.Mesh ) {
                       var geometry = child.geometry.clone();
                       var material = bunnyTexture;
                       bunny = new THREE.Mesh( geometry, material );
                       bunny.receiveShadow = true;
                       bunny.castShadow = true;
                       if (firstIteration == true) {
                           /* Code to get the bounding box of the bunny, getting the max and min points */
                           bunny.geometry.computeBoundingBox();
                           var boundingBox = bunny.geometry.boundingBox;
                           getBoundingBoxModifiers(boundingBox);
                           firstIteration = false;
                       }
                       geometry.translate(-translate.x, -translate.y, -translate.z);
                    }
                 } );
                 /* Scales the bunny to the correct size, and moves it so that it is within the box when the
                  scene is first loaded. */
                 bunny.position.set( 0, 0 , 0 );
                 bunny.scale.set(scale.actual, scale.actual, scale.actual );
                 if ( bunnyParams.draw == true ) scene.add( bunny );
            }
        
            /* function: loadModelMesh - Variation on the loadModel function, and instead of loading the
             texture for the bunny, instead uses the wireframe to draw the "edge" mode for the bunny. */
            function loadModelMesh() {
                bunny.traverse( function ( child ) {
                   if ( child instanceof THREE.Mesh ) {
                       child.geometry.translate(-translate.x, -translate.y, -translate.z);
                       var mesh = new THREE.Mesh( child.geometry, child.material );
                       var useWireFrame = true;
                       if ( useWireFrame ) {
                           mesh.traverse( function(child) {
                              child.material.wireframe = true;
                              child.material.color = new THREE.Color( 0xff0000 );
                           } );
                       }
                       child.receiveShadow = true;
                       child.castShadow = true;
                    }
                } );
                /* Scales the bunny to 50% size, and moves it so that it is within the box when the
                 scene is first loaded. */
                bunny.position.set( 0, 0 , 0 );
                bunny.scale.set(scale.actual, scale.actual, scale.actual);
                if ( bunnyParams.draw == true ) scene.add( bunny );
            }
        
            /* function: loadModelMesh - Variation on the loadModel function, and instead of loading the
             texture for the bunny, instead uses points to draw the "vertices" mode for the bunny. */
            function loadModelPoints() {
                bunny.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        scene.remove( bunny );
                        var geometry = child.geometry.clone();
                        geometry.translate(-translate.x, -translate.y, -translate.z);
                        var material = new THREE.PointsMaterial( { color: 0xFF0000 } );
                        material.size = 0.025;
                        bunny = new THREE.Points( geometry, material );
                        bunny.receiveShadow = true;
                        bunny.castShadow = true;
                     }
                } );
                /* Scales the bunny to 50% size, and moves it so that it is within the box when the
                 scene is first loaded. */
                bunny.position.set( 0, 0 , 0 );
                bunny.scale.set(scale.actual, scale.actual, scale.actual);
                if ( bunnyParams.draw == true ) scene.add( bunny );
            }

            /************************* INITIALISE **************************/
        
            // Initialise the scene, and draw it for the first time.
            init();
            animate();
        
            /* Listens for keyboard events and calls the function handleKeyDown to react to them*/
            document.addEventListener('keydown', handleKeyDown);
            
            // Scene initialisation. This function is only run once, at the very beginning.
            function init() {
                scene = new THREE.Scene();
                
                // Set up the Web GL renderer.
                renderer = new THREE.WebGLRenderer({ antialias: true });
                /* This section sets up the renderer so that it will appear correctly on
                 any screen size, using the dimensions of the sceen to create the scene. */
                renderer.setPixelRatio(window.devicePixelRatio); // HiDPI/retina rendering
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                // Background colour set as black - allows the scene to be rendered as black, giving it the nice aesthetic starfield appearance
                renderer.setClearColor( 0x000000 );
                renderer.clear();
                renderer.shadowMap.enabled = true;
                renderer.shadowCameraFov = 45;
                renderer.shadowMapWidth = 2048;
                renderer.shadowMapHeight = 2048;
                
                // Add a watchlist for handling mouse events
                addMouseHandler( renderer.domElement );
                
                // Rendering shadows and stuff
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Set up the camera with a field-of-view of 45 degrees, an aspect ratio of width/height, and the camera frustrum near and far plane. moveCamera is then called to adjust the position of the camera and the lookAt point. (Preset in global variables)
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
                moveCamera( 0, 0 );
                
                // Setup of ground plane
                var planeTexture = new THREE.TextureLoader().load( 'textures/grass.jpg' );
                // Creating plane Geometry: 20x20 with 10 elements on each side
                var floorGeometry = new THREE.PlaneBufferGeometry( 20, 20, 10, 10);
                var planeMaterial = new THREE.MeshPhongMaterial( {map: planeTexture, side: THREE.DoubleSide} );
                var plane = new THREE.Mesh( floorGeometry , planeMaterial );
                // Rotating the plane so it is normal to the Y-Axis
                plane.rotation.x = -Math.PI / 2;
                // Lowering the plane so it is just barely below where the cube sits normally
                plane.position.y = -1.01;
                plane.receiveShadow = true;
                scene.add( plane );
                
                /* A Point Light is created so that the moon in the scene receives shadows from the 
                 sun in addition to the cube/bunny/plane receiving lights and shadows. */
                dirLight = new THREE.PointLight(0xffffff);
                dirLight.castShadow = true;
                /* Defines the properties of the shadow map for the directional light. The
                 outer bounds of the shadow camera need to be made slightly larger to avoid
                 shadow clipping */
                dirLight.shadow.camera.near = 0.001;
                dirLight.shadow.camera.far = 3500;
                dirLight.shadow.mapSize.width = 1024 ;
                dirLight.shadow.mapSize.height = 1024;
                /* The outer bounds of the shadow camera are set to be wider than the actual ground
                 plane so that the shadow does not clip on the plane. */
                dirLight.shadow.camera.left = -15;
                dirLight.shadow.camera.right = 15;
                dirLight.shadow.camera.top = 15;
                dirLight.shadow.camera.bottom = -15;
                /* updateProjectionMatrix() needs to be called when the camera parameters are
                 updated. */
                dirLight.shadow.camera.updateProjectionMatrix();
                scene.add( dirLight );
                
                // Creating the shape for the directional light sphere, or "moon"
                var dirLightGeometry = new THREE.SphereBufferGeometry( 1, 32, 32 );
                var dirLightTexture = new THREE.TextureLoader().load('textures/sun.jpg');
                var dirLightMaterial = new THREE.MeshPhongMaterial( { map: dirLightTexture } );
                dirLightSrc = new THREE.Mesh( dirLightGeometry, dirLightMaterial);
                scene.add( dirLightSrc );
                
                var dirLightGlowMaterial = new THREE.ShaderMaterial( { uniforms: { 0:   { type: "f", value: 1.0 }, "p":   { type: "f", value: 1.4 }, glowColor: { type: 0, value: new THREE.Color(0xFFFFFF) }, viewVector: { type: "v3", value: camera.position } }, vertexShader:   document.getElementById( 'vertexShader'   ).textContent, fragmentShader: document.getElementById( 'fragmentShader' ).textContent, side: THREE.FrontSide, blending: THREE.AdditiveBlending, transparent: true }   );
                var dirLightGlowGeo = new THREE.SphereBufferGeometry( 1, 32, 32 );
                dirLightGlow = new THREE.Mesh( dirLightGlowGeo , dirLightGlowMaterial );
                dirLightGlow.scale.multiplyScalar(1.1);
                scene.add( dirLightGlow );
                
                var moonTexture = new THREE.TextureLoader().load('textures/moon.jpg');
                var moonGeometry = new THREE.SphereBufferGeometry( 0.5, 32, 32 );
                var moonMaterial = new THREE.MeshPhongMaterial( { map: moonTexture } );
                moon = new THREE.Mesh( moonGeometry, moonMaterial);
                moon.receiveShadow = true;
                moon.castShadow = true;
                scene.add( moon );
                
                // Basic ambient lighting.
                hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.5 );
                hemiLight.position.set( 0, 10, 0 );
                scene.add( hemiLight );

                // Draw a helper grid in the x-z plane (note: y is up).
                grid = new THREE.GridHelper( 10, 20, 0xFFFFFF );
                scene.add( grid );
                grid.visible = false;
                
                // Loading the texture file for the bunny
                bunnyTexture = new THREE.MeshPhongMaterial({ map: new THREE.TextureLoader().load( 'textures/rabbitskin.png' ) });
                // Loading the actual .obj file for the bunny
                var loader = new THREE.OBJLoader( new THREE.LoadingManager ( loadModel ) );
                loader.load( 'bunny-5000.obj', function ( obj ) { bunny = obj; } );

                /* cubeMaterials stores a texture mapped to a phong material corresponding to each of the six (6) sides of the cube. */
                var tex1 = new THREE.TextureLoader().load('textures/tex1.jpg');
                var tex2 = new THREE.TextureLoader().load('textures/tex2.jpg');
                var tex3 = new THREE.TextureLoader().load('textures/tex3.jpg');
                var tex4 = new THREE.TextureLoader().load('textures/tex4.jpg');
                var tex5 = new THREE.TextureLoader().load('textures/tex5.jpg');
                var tex6 = new THREE.TextureLoader().load('textures/tex6.png');
                cubeMaterials = [new THREE.MeshPhongMaterial({ map: tex1 }),
                                 new THREE.MeshPhongMaterial({ map: tex2 }),
                                 new THREE.MeshPhongMaterial({ map: tex3 }),
                                 new THREE.MeshPhongMaterial({ map: tex4 }),
                                 new THREE.MeshPhongMaterial({ map: tex5 }),
                                 new THREE.MeshPhongMaterial({ map: tex6 }) ];
                var cubeGeometry = new THREE.BoxBufferGeometry( 2, 2, 2 );
                cube = new THREE.Mesh( cubeGeometry , cubeMaterials );
                cube.receiveShadow = true;
                cube.castShadow = true;
                scene.add( cube );
                
                /* X,Y,Z Axes set up to display on-screen for a distance of 3 on each axis.
                 The axes can be hidden or displayed by the checkbox in the gui. */
                axes = new THREE.AxesHelper( 3 );
                scene.add( axes );
                axes.visible = false;
                
                /* this section adds a starfield to the background of the scene. This is
                 completely aesthetic, and generates a collection of small white points on a
                 black background so that the scene looks like it's floating in space - it's
                 also just very cool. */
                var starsGeometry = new THREE.Geometry();
                /* Sets up the spread of the stars iterating between a distance of 30 and 10000.
                 This prevents the stars from being generated too closely to the origin and the
                 points showing up as square artifacts in the scene. */
                for ( var i = 30; i < 10000; i ++ ) {
                    var star = new THREE.Vector3();
                    star.x = THREE.Math.randFloatSpread( 2000 );
                    star.y = THREE.Math.randFloatSpread( 2000 );
                    star.z = THREE.Math.randFloatSpread( 2000 );
                    starsGeometry.vertices.push( star );
                }
                /* Sets the colour of the points as white, then creates the actual starfield and
                 adds it to the scene. */
                var starsMaterial = new THREE.PointsMaterial( { color: 0xFFFFFF } );
                var starField = new THREE.Points( starsGeometry, starsMaterial );
                scene.add( starField );
                
                // Handle resizing of the browser window.
				window.addEventListener('resize', handleResize, false);
            }
        
        // Handle resizing of the browser window.
        function handleResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

        // Animation loop function. This function is called whenever an update is required.
        function animate() {
				requestAnimationFrame(animate);
                cubeMovement();
                bunnyMovement();
                lightMovement();
                
                // Render the current scene to the screen.
                renderer.render( scene, camera );
            }
        
        // Handle keyboard presses.
        function handleKeyDown(event) {
                switch (event.keyCode) {
                    /* Render Modes: each of the 3 F/E/V cases will first remove both the cube
                     and the bunny, then load the new mesh if the option to draw that object 
                     has been selected on the GUI. (They will always be created anyway so that
                     they are rendered in the correct mode if the option is then selected.) */
                    case 70: // f = face
                    scene.remove( cube );
                    scene.remove( bunny );
                    cube = new THREE.Mesh( new THREE.BoxBufferGeometry( 2, 2, 2 ), cubeMaterials );
                    cube.receiveShadow = true;
                    cube.castShadow = true;
                    // This line prevents the new cube from being rendered if drawCube is not selected.
                    if ( cubeParams.drawCube == true )
                    scene.add( cube );
                    // Loading the actual .obj file for the bunny
                    var loader = new THREE.OBJLoader( new THREE.LoadingManager ( loadModel ) );
                    loader.load( 'bunny-5000.obj', function ( obj ) { bunny = obj; } );
                    break;

                    case 69: // e = edge
                    scene.remove( cube );
                    scene.remove( bunny );
                    var material = new THREE.MeshPhongMaterial({ color: 0xFF0000, wireframe: true });
                    cube = new THREE.Mesh( new THREE.BoxBufferGeometry( 2, 2, 2 ), material );
                    cube.receiveShadow = true;
                    cube.castShadow = true;
                    if ( cubeParams.drawCube == true )
                    scene.add(cube);
                    var loader = new THREE.OBJLoader( new THREE.LoadingManager ( loadModelMesh ) );
                    loader.load( 'bunny-5000.obj', function ( obj ) { bunny = obj; } );
                    break;

                    case 86: // v = vertex
                    scene.remove( cube );
                    scene.remove( bunny );
                    var geometry = new THREE.BoxBufferGeometry( 2, 2, 2 );
                    var material = new THREE.PointsMaterial( { color: 0xFF0000 } );
                    material.size = 0.2;
                    cube = new THREE.Points( geometry, material );
                    cube.receiveShadow = true;
                    cube.castShadow = true;
                    if ( cubeParams.drawCube == true ) scene.add( cube );
                    // Loading the actual .obj file for the bunny
                    var loader = new THREE.OBJLoader( new THREE.LoadingManager ( loadModelPoints ) );
                    loader.load( 'bunny-5000.obj', function ( obj ) { bunny = obj; } );
                    break;
                    
                    /* This section pans the camera using the keyboard buttons. Within each
                     case statement the current camera position is stored, the camera translated
                     and then the function calcCamDiff called to get the new position of the 
                     difference between the old and new camera position. */
                    case 37:    // Left Arrow
                    oldVector = camera.getWorldDirection().add( camera.position );
                    camera.translateOnAxis(xAxis, (-0.02 * cameraControls.distance) );
                    calcCamDiff();
                    break;
                    
                    case 38:    // Up Arrow
                    oldVector = camera.getWorldDirection().add( camera.position );
                    camera.translateOnAxis(yAxis, (0.02 * cameraControls.distance) );
                    calcCamDiff();
                    break;
                    
                    case 39:    // Right Arrow
                    oldVector = camera.getWorldDirection().add( camera.position );
                    camera.translateOnAxis(xAxis, (0.02 * cameraControls.distance) );
                    calcCamDiff();
                    break;
                    
                    case 40 :   // Down Arrow
                    oldVector = camera.getWorldDirection().add( camera.position );
                    camera.translateOnAxis(yAxis, (-0.02 * cameraControls.distance) );
                    calcCamDiff();
                    break;
                }
            }
 		</script>
	</body>
</html>


